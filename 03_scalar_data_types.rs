// 03_scalar_data_types.rs
// 核心内容：详细介绍基本标量类型：整型、浮点型、布尔型和字符型。

/*
 * =====================================================================================
 * 核心概念讲解 (Comments Section)
 * =====================================================================================
 *
 * Rust 是一门静态类型语言，这意味着它必须在编译时知道所有变量的类型。
 * 通常，编译器可以根据我们赋的值来推断出类型，但有时我们也需要显式地指定类型。
 *
 * 数据类型可以分为两大类：标量（Scalar）和复合（Compound）。
 *
 * - **标量 (Scalar) 类型**: 代表一个 *单个* 值。可以把它想象成一个最小的、不可再分割的数据单元。
 *   例如 `i32` (一个整数), `bool` (一个布尔值), `char` (一个字符)。
 *
 * - **复合 (Compound) 类型**: 将 *多个* 值组合成一个类型。
 *   例如 `(i32, f64)` (一个元组), `[i32; 5]` (一个数组)。
 *
 * **与Java的类比**:
 * 类比为Java中的“基础数据类型”和“引用数据类型”
 * - **相似之处**: Rust的标量类型确实和Java的基础数据类型（`int`, `double`, `char`）非常相似，它们都代表简单的单个值。
 * - **关键区别**: Rust的分类标准是“结构”（单个值 vs 多个值的组合），而Java的分类标准是“内存模型”（值存储 vs 引用存储）。
 *   在Rust中，一个复合类型（如数组 `[i32; 10]`）本身是作为一个完整的值存储在栈上的（如果大小已知），而不是像Java的 `int[]` 那样是一个指向堆内存的引用。
 *   Rust中与“引用类型”更接近的概念是所有权系统中的“引用”（`&`）和存储在堆上的类型（如 `String`, `Vec`）。
 *
 * 本节我们专注于标量类型，它们代表单个值。Rust有四种主要的标量类型。
 *
 * 1. 整型 (Integer Types)
 *    - 整型是没有小数部分的数字。Rust提供了多种整型，用于不同大小的数字。
 *    - 长度    有符号 (Signed)   无符号 (Unsigned)
 *      8-bit      `i8`              `u8`
 *      16-bit     `i16`             `u16`
 *      32-bit     `i32`             `u32` (默认的整数类型)
 *      64-bit     `i64`             `u64`
 *      128-bit    `i128`            `u128`
 *      arch       `isize`           `usize` (大小取决于你的计算机架构，32位或64位)
 *
 *    - `Signed` (i) vs `Unsigned` (u): 有符号类型可以表示负数，而无符号类型只能表示非负数。
 *      例如，`u8` 的范围是 0 到 255，而 `i8` 的范围是 -128 到 127。
 *    - `isize` 和 `usize`: 主要用于索引集合（比如数组），它们的大小能保证足够表示内存中的任何位置。
 *    - 数字字面量：Rust允许使用多种形式的数字字面量，例如 `98_222` (使用 `_` 提高可读性)，
 *      `0xff` (十六进制), `0o77` (八进制), `0b1111_0000` (二进制)。
 *
 * 2. 浮点型 (Floating-Point Types)
 *    - 浮点型是带小数部分的数字。
 *    - `f32`: 32位单精度浮点数。
 *    - `f64`: 64位双精度浮点数 (这是默认类型)。
 *    - 所有浮点型都是有符号的。
 *
 * 3. 布尔型 (Boolean Type)
 *    - 布尔类型只有两个可能的值：`true` 和 `false`。
 *    - 它的大小只有一个字节。
 *    - 使用 `bool` 关键字声明。
 *
 * 4. 字符型 (Character Type)
 *    - `char` 类型是Rust中最基础的字母/符号类型。
 *    - 它使用单引号 `'` 来定义，而字符串使用双引号 `"`。
 *    - 重要的是，Rust的 `char` 类型是 Unicode 标量值，这意味着它可以表示比 ASCII 多得多的字符，
 *      例如中文字符、日文字符、Emoji 等。
 *    - 每个 `char` 类型的大小是4个字节。
 *
 */

// =====================================================================================
// 代码示例 (Code Section)
// =====================================================================================

fn main() {
    // 1. 整型
    let a: i32 = -10; // 显式指定类型
    let b = 98_222;   // 编译器推断为 i32 (默认)
    let c: u8 = 255;  // 无符号8位整数
    println!("Integers: a = {}, b = {}, c = {}", a, b, c);

    // 2. 浮点型
    let x = 2.0; // 编译器推断为 f64 (默认)
    let y: f32 = 3.0; // 显式指定为 f32
    println!("Floats: x = {}, y = {}", x, y);

    // 3. 数值运算
    let sum = 5 + 10;
    let difference = 95.5 - 4.3;
    let product = 4 * 30;
    let quotient = 56.7 / 32.2;
    let remainder = 43 % 5;
    println!(
        "Operations: sum={}, diff={}, prod={}, quot={}, rem={}",
        sum, difference, product, quotient, remainder
    );

    // 4. 布尔型
    let t = true;
    let f: bool = false; // 也可以显式指定类型
    println!("Booleans: t = {}, f = {}", t, f);

    // 5. 字符型
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻'; // Emoji 也是 char!
    println!("Chars: c = {}, z = {}, cat = {}", c, z, heart_eyed_cat);

    // 练习1：
    let integer: u8 = 10;
    let float: f32 = 3.5;
    let result = integer + float as u8; // 这行会报错（已修复）
    println!("Result is {}", result);

    // 练习2：
    //let tmp: u8 = 256;
    //the literal `256` does not fit into the type `u8` whose range is `0..=255`

}

/*
 * =====================================================================================
 * 练习挑战 (Challenge Section)
 * =====================================================================================
 *
 * 1. 类型不匹配:
 *    下面的代码会因为类型不匹配而无法编译。请尝试修改变量的类型或进行类型转换（例如使用 `as` 关键字）来修复它。
 *    提示: Rust 不会自动转换数值类型！
 *
 *    fn challenge_one() {
 *        let integer: u8 = 10;
 *        let float: f32 = 3.5;
 *        // let result = integer + float; // 这行会报错
 *        // println!("Result is {}", result);
 *    }
 *
 * 2. 探索边界:
 *    声明一个 `u8` 类型的变量，并尝试给它赋值 `256`。看看编译器会给你什么错误信息。
 *    这能帮助你理解整型溢出（integer overflow）的概念。在Debug模式下，Rust会panic；
 *    在Release模式下，会发生“环绕”（wrapping）。
 *    a) **编译时检查**: 正如您发现的，直接写 `let tmp: u8 = 256;` 会导致一个编译错误。
 *       这是因为编译器在编译时就能确定 `256` 这个字面量超出了 `u8` (0-255) 的范围。
 *       这是一个很好的安全特性，可以在程序运行前就捕获到明显的错误。
 *
 *    b) **运行时溢出**: `panic` 或“环绕”发生在运行时。请尝试以下代码：
 *       `let max_val: u8 = 255;`
 *       `// let overflow = max_val + 1; // 在 debug 模式下，这行如果取消注释会 panic!`
 *       `// println!("{}", overflow);`
 *       在 `cargo run` (debug模式)下运行，观察程序的 panic。这就是练习中提到的运行时整数溢出。
 *
 */