// 03_scalar_data_types.rs
// 核心内容：详细介绍基本标量类型：整型、浮点型、布尔型和字符型。

/*
 * =====================================================================================
 * 核心概念讲解 (Comments Section)
 * =====================================================================================
 *
 * Rust 是一门静态类型语言，这意味着它必须在编译时知道所有变量的类型。
 * 通常，编译器可以根据我们赋的值来推断出类型，但有时我们也需要显式地指定类型。
 *
 * 数据类型可以分为两大类：标量（Scalar）和复合（Compound）。
 * 本节我们专注于标量类型，它们代表单个值。Rust有四种主要的标量类型。
 *
 * 1. 整型 (Integer Types)
 *    - 整型是没有小数部分的数字。Rust提供了多种整型，用于不同大小的数字。
 *    - 长度    有符号 (Signed)   无符号 (Unsigned)
 *      8-bit      `i8`              `u8`
 *      16-bit     `i16`             `u16`
 *      32-bit     `i32`             `u32` (默认的整数类型)
 *      64-bit     `i64`             `u64`
 *      128-bit    `i128`            `u128`
 *      arch       `isize`           `usize` (大小取决于你的计算机架构，32位或64位)
 *
 *    - `Signed` (i) vs `Unsigned` (u): 有符号类型可以表示负数，而无符号类型只能表示非负数。
 *      例如，`u8` 的范围是 0 到 255，而 `i8` 的范围是 -128 到 127。
 *    - `isize` 和 `usize`: 主要用于索引集合（比如数组），它们的大小能保证足够表示内存中的任何位置。
 *    - 数字字面量：Rust允许使用多种形式的数字字面量，例如 `98_222` (使用 `_` 提高可读性)，
 *      `0xff` (十六进制), `0o77` (八进制), `0b1111_0000` (二进制)。
 *
 * 2. 浮点型 (Floating-Point Types)
 *    - 浮点型是带小数部分的数字。
 *    - `f32`: 32位单精度浮点数。
 *    - `f64`: 64位双精度浮点数 (这是默认类型)。
 *    - 所有浮点型都是有符号的。
 *
 * 3. 布尔型 (Boolean Type)
 *    - 布尔类型只有两个可能的值：`true` 和 `false`。
 *    - 它的大小只有一个字节。
 *    - 使用 `bool` 关键字声明。
 *
 * 4. 字符型 (Character Type)
 *    - `char` 类型是Rust中最基础的字母/符号类型。
 *    - 它使用单引号 `'` 来定义，而字符串使用双引号 `"`。
 *    - 重要的是，Rust的 `char` 类型是 Unicode 标量值，这意味着它可以表示比 ASCII 多得多的字符，
 *      例如中文字符、日文字符、Emoji 等。
 *    - 每个 `char` 类型的大小是4个字节。
 *
 */

// =====================================================================================
// 代码示例 (Code Section)
// =====================================================================================

fn main() {
    // 1. 整型
    let a: i32 = -10; // 显式指定类型
    let b = 98_222;   // 编译器推断为 i32 (默认)
    let c: u8 = 255;  // 无符号8位整数
    println!("Integers: a = {}, b = {}, c = {}", a, b, c);

    // 2. 浮点型
    let x = 2.0; // 编译器推断为 f64 (默认)
    let y: f32 = 3.0; // 显式指定为 f32
    println!("Floats: x = {}, y = {}", x, y);

    // 3. 数值运算
    let sum = 5 + 10;
    let difference = 95.5 - 4.3;
    let product = 4 * 30;
    let quotient = 56.7 / 32.2;
    let remainder = 43 % 5;
    println!(
        "Operations: sum={}, diff={}, prod={}, quot={}, rem={}",
        sum, difference, product, quotient, remainder
    );

    // 4. 布尔型
    let t = true;
    let f: bool = false; // 也可以显式指定类型
    println!("Booleans: t = {}, f = {}", t, f);

    // 5. 字符型
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻'; // Emoji 也是 char!
    println!("Chars: c = {}, z = {}, cat = {}", c, z, heart_eyed_cat);
}

/*
 * =====================================================================================
 * 练习挑战 (Challenge Section)
 * =====================================================================================
 *
 * 1. 类型不匹配:
 *    下面的代码会因为类型不匹配而无法编译。请尝试修改变量的类型或进行类型转换（例如使用 `as` 关键字）来修复它。
 *    提示: Rust 不会自动转换数值类型！
 *
 *    fn challenge_one() {
 *        let integer: u8 = 10;
 *        let float: f32 = 3.5;
 *        // let result = integer + float; // 这行会报错
 *        // println!("Result is {}", result);
 *    }
 *
 * 2. 探索边界:
 *    声明一个 `u8` 类型的变量，并尝试给它赋值 `256`。看看编译器会给你什么错误信息。
 *    这能帮助你理解整型溢出（integer overflow）的概念。在Debug模式下，Rust会panic；
 *    在Release模式下，会发生“环绕”（wrapping）。
 *
 */