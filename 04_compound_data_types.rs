
// 04_compound_data_types.rs
// 核心内容：介绍复合类型：元组（Tuple）和数组（Array）的创建、访问和使用场景。

/*
 * =====================================================================================
 * 核心概念讲解 (Comments Section)
 * =====================================================================================
 *
 * 复合类型可以将多个值组合成一个类型。Rust有两个主要的内置复合类型：元组和数组。
 *
 * 1. 元组 (Tuple)
 *    - 元组是一种将多个不同类型的值组合进一个复合类型的方式。
 *    - 元组的长度是固定的：一旦声明，其大小就不能增长或缩小。
 *    - 我们通过在括号 `()` 内写入一个逗号分隔的值列表来创建一个元组。
 *    - 元组中的每个位置都可以有不同的类型。
 *    - 例如: `let tup: (i32, f64, u8) = (500, 6.4, 1);`
 *
 *    访问元组元素：
 *    - 我们可以使用模式匹配来“解构”（destructure）一个元组，从而获取其中的值。
 *      `let (x, y, z) = tup;`
 *    - 我们也可以使用点号 `.` 加上索引来直接访问元组的元素。
 *      `let five_hundred = tup.0;`
 *      `let one = tup.2;`
 *
 *    使用场景：
 *    - 当你想从一个函数返回多个不同类型的值时，元组非常有用。
 *    - 当你想临时组合一些数据，但又不想麻烦地为其创建一个结构体（struct）时。
 *
 * 2. 数组 (Array)
 *    - 数组是另一种将多个值组合在一起的方式，但与元组不同，数组的每个元素必须是相同的类型。
 *    - 数组的长度也是固定的，和元组一样。
 *    - 我们通过在方括号 `[]` 内写入一个逗号分隔的列表来创建数组。
 *    - 数组的类型签名写作 `[T; N]`，其中 `T` 是元素的类型，`N` 是数组的长度（一个编译时常量）。
 *    - 例如: `let a: [i32; 5] = [1, 2, 3, 4, 5];`
 *
 *    访问数组元素：
 *    - 数组是存储在栈（stack）上的一块连续内存。
 *    - 我们可以使用方括号 `[]` 加上索引来访问数组的元素。
 *      `let first = a[0];`
 *      `let second = a[1];`
 *    - 注意：索引从0开始。
 *
 *    无效的数组元素访问：
 *    - 如果你尝试访问一个超出数组边界的索引（例如，对于长度为5的数组，你尝试访问索引10），
 *      Rust会进行运行时检查。
 *    - 如果访问无效，程序会 `panic`（一个Rust术语，表示程序因错误而退出）。
 *      这使得数组访问在Rust中是内存安全的，可以防止缓冲区溢出等漏洞。
 *
 *    初始化数组的快捷方式：
 *    - 如果你想创建一个包含相同值的数组，可以指定初始值和长度：
 *      `let b = [3; 5];` // 这等同于 `let b = [3, 3, 3, 3, 3];`
 *
 */

// =====================================================================================
// 代码示例 (Code Section)
// =====================================================================================

fn main() {
    // 1. 元组 (Tuple)
    // 创建一个元组，包含不同类型的数据
    let person_info: (&str, i32, bool) = ("Alice", 30, true);

    // 使用解构来获取元组中的值
    let (name, age, is_student) = person_info;
    println!("Name: {}, Age: {}, Is Student: {}", name, age, is_student);

    // 使用索引直接访问元组的元素
    let person_name = person_info.0;
    let person_age = person_info.1;
    println!("Accessing directly: Name is {}, Age is {}", person_name, person_age);

    // 2. 数组 (Array)
    // 创建一个包含5个i32类型整数的数组
    let numbers: [i32; 5];
    println!("The first number is: {}", numbers);
    println!("The third number is: {}", numbers);

    // 创建一个包含月份的数组
    let months = ["January", "February", "March", "April", "May", "June",
                  "July", "August", "September", "October", "November", "December"];
    println!("The second month is: {}", months);

    // 使用快捷方式初始化一个包含8个0的数组
    let byte_buffer = [0; 8];
    println!("The byte buffer's 5th element is: {}", byte_buffer);

    // 访问越界索引会导致 panic
    // 下面这行代码如果取消注释，程序运行时会崩溃
    // let invalid_element = numbers;
    // println!("This will not be printed: {}", invalid_element);
}

/*
 * =====================================================================================
 * 练习挑战 (Challenge Section)
 * =====================================================================================
 *
 * 1. 创建并解构元组:
 *    创建一个名为 `rgb_color` 的元组，用于表示一个RGB颜色。它应该包含三个 `u8` 类型的值，
 *    分别代表红、绿、蓝。例如 `(255, 100, 50)`。
 *
 * 2. 访问数组并计算总和:
 *    创建一个包含5个浮点数（`f64`）的数组，代表一周中5个工作日的开销。
 *    通过索引访问每个元素，并将它们相加，计算出总开销并打印出来。
 *    (我们后面会学习更简单的遍历方法，现在先用索引练习一下！)
 *
 */