// 15_error_handling_panic.rs
// 核心内容：讲解panic!宏，以及何时使用不可恢复的错误处理。

/*
 * =====================================================================================
 * 核心概念讲解 (Comments Section)
 * =====================================================================================
 *
 * Rust 将错误分为两大类：
 * 1. 可恢复错误 (Recoverable Error): 通常表示可以合理地响应和恢复的操作失败，比如文件未找到。
 *    我们通常使用 `Result<T, E>` 来处理这类错误（下一课的主题）。
 * 2. 不可恢复错误 (Unrecoverable Error): 通常是 bug 的同义词，比如尝试访问超出数组边界的索引。
 *    Rust 使用 `panic!` 宏来处理这类错误。
 *
 * 1. `panic!` 宏
 *    - 当 `panic!` 宏被执行时，你的程序会打印一个失败信息，展开（unwind）并清理栈，然后退出。
 *    - “展开”（Unwinding）意味着 Rust 会沿着栈向上回溯，并清理每个遇到的函数所拥有的数据。
 *      这是一个安全保障，确保程序在退出前不会留下混乱的内存状态。
 *    - 或者，你可以选择在 `panic` 时立即“中止”（abort），这会不进行任何清理直接退出程序。
 *      这会使最终的二进制文件更小。你可以在 `Cargo.toml` 中配置 `panic = 'abort'`。
 *
 * 2. 何时应该 `panic!`?
 *    `panic!` 主要用于表示程序进入了一种它无法处理的状态。可以将其理解为“我不知道该如何继续下去”。
 *    通常在以下几种情况中，`panic!` 是合适的：
 *
 *    a) 示例代码、原型或测试:
 *       - 在你编写示例代码来演示某个概念时，或者在编写测试断言失败时，`panic!` 是最直接的方式。
 *       - `unwrap()` 和 `expect()` 方法就是常见的例子，它们在 `Result` 或 `Option` 为 `Err` 或 `None` 时会 `panic`。
 *
 *    b) 违反了代码的基本协定或契约:
 *       - 当你的代码所依赖的某个假设、保证或契约被违反时。
 *       - 例如，如果一个函数接收一个表示年龄的 `Age` 类型，而这个类型被设计为永远只包含1到120之间的值。
 *         如果在函数内部，你收到了一个值为200的 `Age` 实例，这表示上游代码有bug，此时 `panic` 是合理的。
 *
 *    c) 编译器无法保证的无效状态:
 *       - 当你调用一个函数，其输入值的某些状态是无效的，但这种状态又很难用类型系统在编译时检查出来。
 *       - 如果你的代码逻辑最终导致了这种无效状态，那么 `panic` 可能比返回一个错误更合适，因为它指出了一个编程错误。
 *
 * 3. `panic!` 的回溯信息 (Backtrace)
 *    - 当 `panic` 发生时，你通常会看到一个调用栈的回溯信息，它能帮助你定位到 `panic` 的源头。
 *    - 为了能看到详细的回溯信息，你需要启用调试符号。在运行 `cargo run` 时，这是默认开启的。
 *    - 你可以设置环境变量 `RUST_BACKTRACE=1` 来获取一个完整的、详细的回溯。
 *      例如: `RUST_BACKTRACE=1 cargo run`
 *
 * 总结：
 * `panic!` 应该用于处理真正的程序错误，即那些表示你的代码逻辑中存在需要修复的 bug 的情况。
 * 对于那些预期可能发生、并且调用者应该知道如何处理的错误（如用户输入错误、网络中断），
 * 你应该使用 `Result<T, E>`。
 *
 */

// =====================================================================================
// 代码示例 (Code Section)
// =====================================================================================

fn main() {
    // 1. 显式调用 panic!
    // 这会立即让程序崩溃，并打印出我们提供的消息。
    // panic!("Farewell, cruel world!");

    // 2. 由代码错误引起的 panic
    // 这是一个非常常见的 panic 场景：访问数组越界。
    let v: Vec<i32> = vec![1,2,3];

    // 练习1：
    //println!("{}",v[5]);//index out of bounds: the len is 3 but the index is 5
    // v 只有3个元素，索引是 0, 1, 2。访问索引 5 会导致 panic。
    // 注意：这个 panic 是由 `Vec` 的索引实现 `[]` 触发的。
    // v;

    println!("This line will never be reached if the panic occurs.");

    // 练习2：
    //println!("{}",divide(8, 0));// division by zero
}
fn divide(a :i32,b :i32)->i32{
    if b == 0 {
        panic!("division by zero");
    }else {
        a / b
    }
}
/*
 * =====================================================================================
 * 练习挑战 (Challenge Section)
 * =====================================================================================
 *
 * 1. 探索 `RUST_BACKTRACE`:
 *    - 取消上面 `v[5]` 那行代码的注释。
 *    - 在你的终端中，运行 `cargo run`，观察默认的 panic 输出。
 *    - 然后，运行 `RUST_BACKTRACE=1 cargo run` (在 PowerShell 中可能是 `$env:RUST_BACKTRACE=1; cargo run`)。
 *    - 比较两次输出的不同，看看详细的回溯信息能为你提供多少关于错误来源的线索。
 *
 * 2. 创建一个会 panic 的函数:
 *    编写一个名为 `divide` 的函数，它接收两个整数 `a` 和 `b`。
 *    如果 `b` 是 `0`，这个函数应该 `panic!` 并给出一个明确的错误信息 "division by zero"。
 *    否则，它应该返回 `a / b` 的结果。
 *    在 `main` 函数中用不同的输入调用它，包括用 `0` 作为除数来触发 panic。
 *
 */